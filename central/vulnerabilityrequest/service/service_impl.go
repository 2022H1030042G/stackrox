package service

import (
	"context"

	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"github.com/pkg/errors"
	"github.com/stackrox/rox/central/role/resources"
	"github.com/stackrox/rox/central/vulnerabilityrequest/datastore"
	"github.com/stackrox/rox/central/vulnerabilityrequest/utils"
	"github.com/stackrox/rox/central/vulnerabilityrequest/validator"
	v1 "github.com/stackrox/rox/generated/api/v1"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/auth/permissions"
	"github.com/stackrox/rox/pkg/errorhelpers"
	"github.com/stackrox/rox/pkg/grpc/authz"
	"github.com/stackrox/rox/pkg/grpc/authz/or"
	"github.com/stackrox/rox/pkg/grpc/authz/perrpc"
	"github.com/stackrox/rox/pkg/grpc/authz/user"
	"github.com/stackrox/rox/pkg/search"
	"github.com/stackrox/rox/pkg/uuid"
	"google.golang.org/grpc"
)

var (
	authorizer = perrpc.FromMap(map[authz.Authorizer][]string{
		or.Or(
			user.With(permissions.View(resources.VulnerabilityManagementRequests)),
			user.With(permissions.View(resources.VulnerabilityManagementApprovals))): {
			"/v1.VulnerabilityRequestService/GetVulnerabilityRequest",
			"/v1.VulnerabilityRequestService/ListVulnerabilityRequests",
		},
		or.Or(
			user.With(permissions.Modify(resources.VulnerabilityManagementRequests)),
			user.With(permissions.Modify(resources.VulnerabilityManagementApprovals))): {
			"/v1.VulnerabilityRequestService/UndoVulnerabilityRequest",
		},
		user.With(permissions.Modify(resources.VulnerabilityManagementRequests)): {
			"/v1.VulnerabilityRequestService/DeferVulnerability",
			"/v1.VulnerabilityRequestService/FalsePositiveVulnerability",
			"/v1.VulnerabilityRequestService/DeleteVulnerabilityRequest",
		},
		user.With(permissions.Modify(resources.VulnerabilityManagementApprovals)): {
			"/v1.VulnerabilityRequestService/ApproveVulnerabilityRequest",
			"/v1.VulnerabilityRequestService/DenyVulnerabilityRequest",
		},
	})
)

// serviceImpl provides APIs for vulnerability requests.
type serviceImpl struct {
	datastore datastore.DataStore
}

// RegisterServiceServer registers this service with the given gRPC Server.
func (s *serviceImpl) RegisterServiceServer(grpcServer *grpc.Server) {
	v1.RegisterVulnerabilityRequestServiceServer(grpcServer, s)
}

// RegisterServiceHandler registers this service with the given gRPC Gateway endpoint.
func (s *serviceImpl) RegisterServiceHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return v1.RegisterVulnerabilityRequestServiceHandler(ctx, mux, conn)
}

// AuthFuncOverride specifies the auth criteria for this API.
func (s *serviceImpl) AuthFuncOverride(ctx context.Context, fullMethodName string) (context.Context, error) {
	return ctx, authorizer.Authorized(ctx, fullMethodName)
}

// GetVulnerabilityRequest returns the requested vulnerability request by ID.
func (s *serviceImpl) GetVulnerabilityRequest(ctx context.Context, req *v1.ResourceByID) (*v1.GetVulnerabilityRequestResponse, error) {
	if req.GetId() == "" {
		return nil, errors.New("vulnerability request ID must be provided")
	}
	requestInfo, _, err := s.datastore.Get(ctx, req.GetId())
	return &v1.GetVulnerabilityRequestResponse{
		RequestInfo: requestInfo,
	}, err
}

// ListVulnerabilityRequests returns the list of vulnerability requests.
func (s *serviceImpl) ListVulnerabilityRequests(ctx context.Context, req *v1.RawQuery) (*v1.ListVulnerabilityRequestsResponse, error) {
	parsedQuery, err := search.ParseQuery(req.GetQuery(), search.MatchAllIfEmpty())
	if err != nil {
		return nil, errors.Wrap(errorhelpers.ErrInvalidArgs, err.Error())
	}
	ret, err := s.datastore.SearchRawRequests(ctx, parsedQuery)
	if err != nil {
		return nil, err
	}
	return &v1.ListVulnerabilityRequestsResponse{
		RequestInfos: ret,
	}, nil
}

// DeferVulnerability starts the deferral process for the specified vulnerability.
func (s *serviceImpl) DeferVulnerability(ctx context.Context, req *v1.DeferVulnRequest) (*v1.DeferVulnResponse, error) {
	deferralReq := utils.CreateVulnRequestProto(ctx, req.GetCve(), storage.VulnerabilityState_DEFERRED, req.GetScope(), req.GetComment())

	if req.GetExpiresWhenFixed() {
		deferralReq.GetDeferralReq().Expiry = &storage.DeferralRequest_ExpiresWhenFixed{
			ExpiresWhenFixed: true,
		}
	} else {
		deferralReq.GetDeferralReq().Expiry = &storage.DeferralRequest_ExpiresOn{
			ExpiresOn: req.GetExpiresOn(),
		}
	}

	if err := validator.ValidateNewSuppressVulnRequest(deferralReq); err != nil {
		return nil, errors.Wrap(errorhelpers.ErrInvalidArgs, err.Error())
	}

	deferralReq.Id = uuid.NewV4().String()

	// TODO: Validate that Vuln is not unwatched already for the scope. Integrate with cache.
	// TODO: Validate there are no pending requests of same type in the same scope. Integrate with cache.

	if err := s.datastore.AddRequest(ctx, deferralReq); err != nil {
		return nil, errors.Wrap(err, "could not create deferral request")
	}

	return &v1.DeferVulnResponse{
		RequestInfo: deferralReq,
	}, nil
}

// FalsePositiveVulnerability starts the process to mark the specified vulnerability as false-positive.
func (s *serviceImpl) FalsePositiveVulnerability(ctx context.Context, req *v1.FalsePositiveVulnRequest) (*v1.FalsePositiveVulnResponse, error) {
	fpRequest := utils.CreateVulnRequestProto(ctx, req.GetCve(), storage.VulnerabilityState_FALSE_POSITIVE, req.GetScope(), req.GetComment())

	if err := validator.ValidateNewSuppressVulnRequest(fpRequest); err != nil {
		return nil, errors.Wrap(errorhelpers.ErrInvalidArgs, err.Error())
	}

	fpRequest.Id = uuid.NewV4().String()

	// TODO: Validate that Vuln is not unwatched already for the scope. Integrate with cache.
	// TODO: Validate there are no pending requests of same type in the same scope. Integrate with cache.

	if err := s.datastore.AddRequest(ctx, fpRequest); err != nil {
		return nil, errors.Wrap(err, "could not create false-positive request")
	}

	return &v1.FalsePositiveVulnResponse{
		RequestInfo: fpRequest,
	}, nil
}

func (s *serviceImpl) ApproveVulnerabilityRequest(ctx context.Context, req *v1.ApproveVulnRequest) (*v1.ApproveVulnRequestResponse, error) {
	requestInfo, err := s.datastore.UpdateRequestStatus(ctx, req.GetId(), req.GetComment(), storage.RequestStatus_APPROVED)
	if err != nil {
		return nil, errors.Wrapf(err, "approving vulnerability request %s", req.GetId())
	}

	// TODO: integrate with caches
	// TODO: (ROX-8186) [BE] All CVEs that are deferred or marked as FP should be excluded from risk calculation
	// TODO: (ROX-8185) [BE] No CVEs that are deferred or marked as FP should not result in a policy violation

	return &v1.ApproveVulnRequestResponse{
		RequestInfo: requestInfo,
	}, nil
}

func (s *serviceImpl) DenyVulnerabilityRequest(ctx context.Context, req *v1.DenyVulnRequest) (*v1.DenyVulnRequestResponse, error) {
	requestInfo, err := s.datastore.UpdateRequestStatus(ctx, req.GetId(), req.GetComment(), storage.RequestStatus_DENIED)
	if err != nil {
		return nil, errors.Wrapf(err, "denying vulnerability request %s", req.GetId())
	}

	// TODO: integrate with caches

	return &v1.DenyVulnRequestResponse{
		RequestInfo: requestInfo,
	}, nil
}

func (s *serviceImpl) UndoVulnerabilityRequest(ctx context.Context, req *v1.ResourceByID) (*v1.UndoVulnRequestResponse, error) {
	requestInfo, err := s.datastore.MarkRequestInactive(ctx, req.GetId())
	if err != nil {
		return nil, errors.Wrapf(err, "undoing vulnerability request %s", req.GetId())
	}

	// TODO: update caches
	// TODO: trigger risk and policy calc

	return &v1.UndoVulnRequestResponse{
		RequestInfo: requestInfo,
	}, nil
}

func (s *serviceImpl) DeleteVulnerabilityRequest(ctx context.Context, req *v1.ResourceByID) (*v1.Empty, error) {
	return &v1.Empty{}, s.datastore.RemoveRequest(ctx, req.GetId(), false)
}
