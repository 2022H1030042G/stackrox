package validator

import (
	"github.com/docker/distribution/reference"
	"github.com/pkg/errors"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/errorhelpers"
)

// ValidateNewSuppressVulnRequest ensures that the new request to suppress vulnerability is correct.
func ValidateNewSuppressVulnRequest(req *storage.VulnerabilityRequest) error {
	var errors errorhelpers.ErrorList
	errors.AddError(validateNoID(req))
	errors.AddError(validateComment(req))
	errors.AddError(validateNoApprovedStatus(req))
	errors.AddError(validateNoDeniedStatus(req))
	errors.AddError(validateTargetState(req))
	errors.AddError(validateScope(req))
	errors.AddError(validateEntities(req))
	errors.AddError(validateActive(req))
	return errors.ToError()
}

func validateNoID(req *storage.VulnerabilityRequest) error {
	if req.GetId() != "" {
		return errors.New("new vulnerability request must not have ID")
	}
	return nil
}

func validateComment(req *storage.VulnerabilityRequest) error {
	if len(req.GetComments()) == 0 {
		return errors.New("vulnerability request must have at least one comment")
	}
	return nil
}

func validateTargetState(req *storage.VulnerabilityRequest) error {
	if req.GetTargetState() != storage.VulnerabilityState_DEFERRED &&
		req.GetTargetState() != storage.VulnerabilityState_FALSE_POSITIVE {
		return errors.New("request to suppress vulnerability must be a deferral or false-positive request")
	}

	if req.GetTargetState() == storage.VulnerabilityState_DEFERRED {
		if req.GetDeferralReq() == nil || req.GetDeferralReq().GetExpiry() == nil {
			return errors.New("vulnerability deferral request invalid. Deferral expiry not provided.")
		}
	}

	if req.GetTargetState() == storage.VulnerabilityState_FALSE_POSITIVE {
		if req.GetFpRequest() == nil {
			return errors.New("request to mark vulnerability false-positive is invalid. False-positive configuration not provided.")
		}
	}
	return nil
}

func validateNoApprovedStatus(req *storage.VulnerabilityRequest) error {
	if req.GetStatus() == storage.RequestStatus_APPROVED {
		return errors.New("new vulnerability request must not be in approved state")
	}
	return nil
}

func validateNoDeniedStatus(req *storage.VulnerabilityRequest) error {
	if req.GetStatus() == storage.RequestStatus_DENIED {
		return errors.New("new vulnerability request must not be in denied state")
	}
	return nil
}

func validateScope(req *storage.VulnerabilityRequest) error {
	if req.GetScope() == nil || (req.GetScope().GetImageScope() == nil && req.GetScope().GetGlobalScope() == nil) {
		return errors.New("vulnerability request must have scope")
	}

	if imageScope := req.GetScope().GetImageScope(); imageScope != nil {
		if imageScope.GetName() == "" {
			return errors.New("vulnerability request with image scope must have image name")
		}
		if _, err := reference.ParseAnyReference(imageScope.GetName()); err != nil {
			return errors.Errorf("vulnerability request has invalid image name %s", imageScope.GetName())
		}

		if imageScope.GetTagRegex() == "" {
			return errors.New("vulnerability request with image scope must have tag regex")
		}

		if imageScope.GetTagRegex() != ".*" {
			if _, err := reference.ParseAnyReference(imageScope.GetName() + ":" + imageScope.GetTagRegex()); err != nil {
				return errors.Errorf("vulnerability request has invalid image name %s", imageScope.GetName())
			}
		}
	}
	return nil
}

func validateEntities(req *storage.VulnerabilityRequest) error {
	if len(req.GetCves().GetIds()) == 0 {
		return errors.New("request must indicate the vulnerabilities for which request is opened")
	}
	return nil
}

func validateActive(req *storage.VulnerabilityRequest) error {
	if !req.GetActive() {
		return errors.New("expected vulnerability request to be active")
	}
	return nil
}
