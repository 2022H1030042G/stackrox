package datastore

import (
	"context"

	"github.com/gogo/protobuf/types"
	"github.com/pkg/errors"
	"github.com/stackrox/rox/central/vulnerabilityrequest/datastore/internal/searcher"
	"github.com/stackrox/rox/central/vulnerabilityrequest/datastore/internal/store"
	"github.com/stackrox/rox/central/vulnerabilityrequest/index"
	"github.com/stackrox/rox/central/vulnerabilityrequest/utils"
	v1 "github.com/stackrox/rox/generated/api/v1"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/batcher"
	"github.com/stackrox/rox/pkg/search"
)

const (
	allTagsRegexStr   = ".*"
	allImagesRegexStr = ".*"
	batchSize         = 1000
)

type datastoreImpl struct {
	store    store.Store
	index    index.Indexer
	searcher searcher.Searcher
}

func (ds *datastoreImpl) buildIndex() error {
	ids, err := ds.store.GetIDs()
	if err != nil {
		return errors.Wrap(err, "error retrieving keys to index from store")
	}

	log.Infof("[STARTUP] Found %d vulnerability requests to index", len(ids))

	vulnReqBatcher := batcher.New(len(ids), batchSize)
	for start, end, valid := vulnReqBatcher.Next(); valid; start, end, valid = vulnReqBatcher.Next() {
		vulnReqs, _, err := ds.store.GetMany(ids[start:end])
		if err != nil {
			return err
		}
		if err := ds.index.AddVulnerabilityRequests(vulnReqs); err != nil {
			return err
		}
		log.Infof("[STARTUP] Successfully indexed %d/%d vulnerability requests", end, len(ids))
	}

	log.Info("[STARTUP] Successfully indexed all vulnerability requests")
	return nil
}

func (ds *datastoreImpl) Search(ctx context.Context, q *v1.Query) ([]search.Result, error) {
	return ds.searcher.Search(ctx, q)
}

func (ds *datastoreImpl) SearchRequests(ctx context.Context, q *v1.Query) ([]*v1.SearchResult, error) {
	return ds.searcher.SearchRequests(ctx, q)
}

func (ds *datastoreImpl) SearchRawRequests(ctx context.Context, q *v1.Query) ([]*storage.VulnerabilityRequest, error) {
	return ds.searcher.SearchRawRequests(ctx, q)
}

func (ds *datastoreImpl) Count(ctx context.Context, q *v1.Query) (int, error) {
	return ds.searcher.Count(ctx, q)
}

func (ds *datastoreImpl) Exists(ctx context.Context, id string) (bool, error) {
	// TODO: Perform SAC check
	return ds.store.Exists(id)
}

func (ds *datastoreImpl) Get(ctx context.Context, id string) (*storage.VulnerabilityRequest, bool, error) {
	// TODO: Perform SAC check
	return ds.store.Get(id)
}

func (ds *datastoreImpl) GetMany(ctx context.Context, ids []string) ([]*storage.VulnerabilityRequest, error) {
	// TODO: Perform SAC check
	ret, _, err := ds.store.GetMany(ids)
	return ret, err
}

func (ds *datastoreImpl) AddRequest(ctx context.Context, request *storage.VulnerabilityRequest) error {
	// TODO: Perform SAC check
	if err := ds.store.Upsert(request); err != nil {
		return err
	}
	if err := ds.index.AddVulnerabilityRequest(request); err != nil {
		return err
	}
	// TODO: integrate with cache.
	return nil
}

func (ds *datastoreImpl) UpdateRequestStatus(ctx context.Context, id, message string, status storage.RequestStatus) (*storage.VulnerabilityRequest, error) {
	if id == "" {
		return nil, errors.New("vulnerability request ID must be provided")
	}
	if status == storage.RequestStatus_PENDING {
		return nil, errors.New("vulnerability request cannot be moved to pending state")
	}
	if message == "" {
		return nil, errors.New("comment is required when approving/denying a vulnerability request")
	}

	// TODO: Perform SAC check

	req, found, err := ds.store.Get(id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, errors.Errorf("vulnerability request %s not found", id)
	}

	req.LastUpdated = types.TimestampNow()
	req.Approvers = append(req.Approvers, utils.UserFromContext(ctx))
	req.Comments = append(req.Comments, utils.CreateRequestCommentProto(ctx, message))
	req.Status = status

	if err := ds.store.Upsert(req); err != nil {
		return nil, err
	}
	if err := ds.index.AddVulnerabilityRequest(req); err != nil {
		return nil, err
	}
	return req, nil
}

func (ds *datastoreImpl) MarkRequestInactive(ctx context.Context, id string) (*storage.VulnerabilityRequest, error) {
	// TODO: Perform SAC check. Requestor or Approver.
	req, found, err := ds.store.Get(id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, errors.Errorf("vulnerability request %s not found", id)
	}

	if !req.GetActive() {
		return nil, errors.Errorf("vulnerability request %s is inactive. Undo is noop", id)
	}

	req.LastUpdated = types.TimestampNow()
	req.Comments = append(req.Comments, utils.CreateRequestCommentProto(ctx, "[System Generated] Request undone"))
	req.Active = false

	if err := ds.store.Upsert(req); err != nil {
		return nil, err
	}
	if err := ds.index.AddVulnerabilityRequest(req); err != nil {
		return nil, err
	}
	return req, nil
}

func (ds *datastoreImpl) RemoveRequest(ctx context.Context, id string, force bool) error {
	// TODO: Perform SAC check
	req, found, err := ds.store.Get(id)
	if err != nil {
		return err
	}
	if !found {
		return errors.Errorf("vulnerability request %s not found", id)
	}

	if !force {
		if req.GetStatus() != storage.RequestStatus_PENDING {
			return errors.New("only pending vulnerability requests can be cancelled")
		}
	}
	// There is nothing else to do, this only called by garbage collector on already requests otherwise.
	return ds.store.Delete(id)
}
