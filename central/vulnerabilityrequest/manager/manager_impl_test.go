package manager

import (
	"context"
	"testing"
	"time"

	"github.com/gogo/protobuf/types"
	"github.com/stackrox/rox/central/globalindex"
	"github.com/stackrox/rox/central/vulnerabilityrequest/datastore"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/concurrency"
	"github.com/stackrox/rox/pkg/features"
	"github.com/stackrox/rox/pkg/fixtures"
	"github.com/stackrox/rox/pkg/protoconv"
	"github.com/stackrox/rox/pkg/rocksdb"
	"github.com/stackrox/rox/pkg/sac"
	"github.com/stackrox/rox/pkg/testutils/envisolator"
	"github.com/stackrox/rox/pkg/testutils/rocksdbtest"
	"github.com/stretchr/testify/suite"
)

var (
	allAllowedCtx             = sac.WithAllAccess(context.Background())
	expiryLoopDurationForTest = 5 * time.Second // use a much quicker loop for testing purposes
)

func TestVulnRequestManager(t *testing.T) {
	suite.Run(t, new(VulnRequestManagerTestSuite))
}

type VulnRequestManagerTestSuite struct {
	suite.Suite
	envIsolator *envisolator.EnvIsolator

	db        *rocksdb.RocksDB
	datastore datastore.DataStore

	manager *managerImpl
}

func (s *VulnRequestManagerTestSuite) SetupSuite() {
	s.db = rocksdbtest.RocksDBForT(s.T())
}

func (s *VulnRequestManagerTestSuite) TearDownSuite() {
	rocksdbtest.TearDownRocksDB(s.db)
}

func (s *VulnRequestManagerTestSuite) SetupTest() {
	s.envIsolator = envisolator.NewEnvIsolator(s.T())
	s.envIsolator.Setenv(features.VulnRiskManagement.EnvVar(), "true")

	bleveIndex, err := globalindex.MemOnlyIndex()
	s.NoError(err)

	ds, err := datastore.NewForTestOnly(s.T(), s.db, bleveIndex)
	s.NoError(err)
	s.datastore = ds

	s.manager = &managerImpl{
		datastore:                        s.datastore,
		reObserveDeferralsTickerDuration: expiryLoopDurationForTest,
		stopSig:                          concurrency.NewSignal(),
		stopped:                          concurrency.NewSignal(),
	}

	if !features.VulnRiskManagement.Enabled() {
		s.T().Skip("Skip vuln management manager test")
		s.T().SkipNow()
	}
}

func (s *VulnRequestManagerTestSuite) TestReObserveExpiredDeferralsMarksAllAsInactive() {
	expiredOneDayAgo := protoconv.ConvertTimeToTimestamp(time.Now().Add(-24 * time.Hour))
	expiresInFuture := protoconv.ConvertTimeToTimestamp(time.Now().Add(30 * 24 * time.Hour))

	fpRequest := fixtures.GetGlobalFPRequest("cve-a-b")
	fpRequest.Status = storage.RequestStatus_APPROVED

	cases := []struct {
		name             string
		vulnRequest      *storage.VulnerabilityRequest
		shouldBeActive   bool
		shouldGetComment bool
	}{
		{
			name:             "Active and approved deferral with expiry in past should be marked inactive with comment",
			vulnRequest:      s.newDeferral("req-active-def", true, storage.RequestStatus_APPROVED, expiredOneDayAgo),
			shouldBeActive:   false,
			shouldGetComment: true,
		},
		{
			name:             "Inactive deferral should remain inactive but with no additional comment",
			vulnRequest:      s.newDeferral("req-inactive-def", false, storage.RequestStatus_APPROVED, expiredOneDayAgo),
			shouldBeActive:   false,
			shouldGetComment: false,
		},
		{
			name:             "Pending deferral should not be marked as inactive",
			vulnRequest:      s.newDeferral("req-pending-def", true, storage.RequestStatus_PENDING, expiredOneDayAgo),
			shouldBeActive:   true,
			shouldGetComment: false,
		},
		{
			name:             "Denied deferral should not be marked as inactive",
			vulnRequest:      s.newDeferral("req-denied-def", true, storage.RequestStatus_DENIED, expiredOneDayAgo),
			shouldBeActive:   true,
			shouldGetComment: false,
		},
		{
			name:             "Deferral with expiry in future should not be marked as inactive",
			vulnRequest:      s.newDeferral("req-unexpired-def", true, storage.RequestStatus_APPROVED, expiresInFuture),
			shouldBeActive:   true,
			shouldGetComment: false,
		},
		{
			name:             "Deferrals with expires when fixed should not be marked as inactive",
			vulnRequest:      s.newDeferralExpiresWhenFixed("req-whenfixed-def", true, storage.RequestStatus_APPROVED),
			shouldBeActive:   true,
			shouldGetComment: false,
		},
		{
			name:             "False positive requests should not be marked as inactive",
			vulnRequest:      fpRequest,
			shouldBeActive:   true,
			shouldGetComment: false,
		},
	}
	for _, c := range cases {
		s.T().Run(c.name, func(t *testing.T) {
			err := s.datastore.AddRequest(allAllowedCtx, c.vulnRequest)
			s.NoError(err)

			s.manager.reObserveExpiredDeferrals()

			r, ok, err := s.datastore.Get(allAllowedCtx, c.vulnRequest.GetId())
			s.NoError(err)
			s.True(ok)
			s.Equal(c.shouldBeActive, r.Active)

			if c.shouldGetComment {
				s.Len(r.Comments, 1)
				s.Equal(r.Comments[0].Message, "[System Generated] Request expired")
				s.Nil(r.Comments[0].User) // system generated so no user identity
			} else {
				s.Len(r.Comments, 0)
			}
		})
	}
}

func (s *VulnRequestManagerTestSuite) TestProcessorDoesntInactivateOnceStopped() {
	s.manager.Start()
	time.Sleep(expiryLoopDurationForTest) // wait for it to run at least once

	// Now stop it
	s.manager.Stop()

	// Add in a request that should be expired if it wasn't stopped
	req := s.newDeferral("req", true, storage.RequestStatus_APPROVED, protoconv.ConvertTimeToTimestamp(time.Now().Add(-24*time.Hour)))
	err := s.datastore.AddRequest(allAllowedCtx, req)
	s.NoError(err)

	// Wait again for what would've been two loops
	time.Sleep(expiryLoopDurationForTest * 2)

	// Verify request wasn't marked inactive
	r, ok, err := s.datastore.Get(allAllowedCtx, req.GetId())
	s.NoError(err)
	s.True(ok)
	s.True(r.Active)
}

func (s *VulnRequestManagerTestSuite) newDeferral(id string, active bool, status storage.RequestStatus, expiry *types.Timestamp) *storage.VulnerabilityRequest {
	return &storage.VulnerabilityRequest{
		Id:     id,
		Status: status,
		Active: active,
		Req: &storage.VulnerabilityRequest_DeferralReq{
			DeferralReq: &storage.DeferralRequest{
				Expiry: &storage.DeferralRequest_ExpiresOn{ExpiresOn: expiry},
			},
		},
	}
}

func (s *VulnRequestManagerTestSuite) newDeferralExpiresWhenFixed(id string, active bool, status storage.RequestStatus) *storage.VulnerabilityRequest {
	return &storage.VulnerabilityRequest{
		Id:     id,
		Status: status,
		Active: active,
		Req: &storage.VulnerabilityRequest_DeferralReq{
			DeferralReq: &storage.DeferralRequest{
				Expiry: &storage.DeferralRequest_ExpiresWhenFixed{ExpiresWhenFixed: true},
			},
		},
	}
}
