package manager

import (
	"context"
	"fmt"
	"time"

	"github.com/pkg/errors"
	"github.com/stackrox/rox/central/role/resources"
	"github.com/stackrox/rox/central/vulnerabilityrequest/datastore"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/concurrency"
	"github.com/stackrox/rox/pkg/errorhelpers"
	"github.com/stackrox/rox/pkg/features"
	"github.com/stackrox/rox/pkg/sac"
	"github.com/stackrox/rox/pkg/search"
)

var (
	// Give the processor access as an approver so that it can properly expire
	allVulnApproverAccessSac = sac.WithGlobalAccessScopeChecker(context.Background(),
		sac.AllowFixedScopes(
			sac.AccessModeScopeKeys(storage.Access_READ_ACCESS, storage.Access_READ_WRITE_ACCESS),
			sac.ResourceScopeKeys(resources.VulnerabilityManagementApprovals)))
)

type managerImpl struct {
	datastore datastore.DataStore

	reObserveDeferralsTickerDuration time.Duration

	stopSig concurrency.Signal
	stopped concurrency.Signal
}

func (m *managerImpl) Start() {
	if !features.VulnRiskManagement.Enabled() {
		return
	}
	go m.runExpiredDeferralsProcessor()
}

func (m *managerImpl) Stop() {
	m.stopSig.Signal()
	m.stopped.Wait()
}

// SnoozeVulnerabilityOnRequest snoozes the CVE for the scope specified by the request
// Snoozed vulns won't result in a policy violation nor will it be included in risk calculation.
func (m *managerImpl) SnoozeVulnerabilityOnRequest(ctx context.Context, requestID string) error {
	req, found, err := m.datastore.Get(ctx, requestID)
	if err != nil {
		return err
	}
	if !found {
		return errors.Errorf("vulnerability request %s not found", requestID)
	}

	// Only snooze the vulns if the request was fully approved
	if req.GetExpired() || req.GetStatus() != storage.RequestStatus_APPROVED {
		return errors.Errorf("vulnerability request %s not approved or expired", requestID)
	}

	// TODO: (ROX-8186) [BE] All CVEs that are deferred or marked as FP should be excluded from risk calculation
	// TODO: (ROX-8185) [BE] No CVEs that are deferred or marked as FP should not result in a policy violation

	return nil
}

// UnSnoozeVulnerabilityOnRequest unsnoozes the CVE for the scope specified by the request
// unless there is another request that is still active that causes this CVE to remain snoozed
func (m *managerImpl) UnSnoozeVulnerabilityOnRequest(ctx context.Context, requestID string) error {
	// TODO: Fail out if there exists another request that is still active that causes this CVE to be snoozed
	// TODO: recalculate risk and policy evaluation with the CVE(s) in this request included
	return nil
}

func (m *managerImpl) getExpiredDeferrals() ([]string, error) {
	now := fmt.Sprintf("<%s", time.Now().Format("01/02/2006 MST"))
	q := search.NewQueryBuilder().
		AddStrings(search.RequestStatus, storage.RequestStatus_APPROVED.String()). // only expire approved ones
		AddGenericTypeLinkedFields([]search.FieldLabel{search.ExpiredRequest, search.DeferralExpiryTime}, []interface{}{false, now}).
		ProtoQuery()
	results, err := m.datastore.Search(allVulnApproverAccessSac, q)

	if err != nil || len(results) == 0 {
		return nil, err
	}
	return search.ResultsToIDs(results), nil
}

func (m *managerImpl) reObserveExpiredDeferrals() {
	if m.stopped.IsDone() {
		return
	}

	deferrals, err := m.getExpiredDeferrals()
	if err != nil {
		log.Errorf("error retrieving expired deferral requests for reprocessing: %v", err)
		return
	}
	if len(deferrals) == 0 {
		return
	}

	processingErrs := errorhelpers.NewErrorList("re-observing expired deferrals")
	for _, reqID := range deferrals {
		// A request can be re-observed by just marking it inactive
		// NOTE: It is possible that another request will still force this vulnerability to be deferred (e.g. if this was image scoped
		// but a global one still exists).
		if _, err := m.datastore.MarkRequestInactive(allVulnApproverAccessSac, reqID, "[System Generated] Request expired"); err != nil {
			processingErrs.AddWrapf(err, "marking as inactive request %s", reqID)
		} else {
			if err := m.UnSnoozeVulnerabilityOnRequest(allVulnApproverAccessSac, reqID); err != nil {
				processingErrs.AddWrapf(err, "unsnoozing vulns for request %s", reqID)
			}
			// TODO: Clear from cache(s)
		}
	}

	if err := processingErrs.ToError(); err != nil {
		log.Errorf("Failed to re-observe some of the expired deferrals with error(s): %+v", err)
	} else {
		log.Infof("Completed attempt to re-observe expired deferral %d requests", len(deferrals))
	}
}

func (m *managerImpl) runExpiredDeferralsProcessor() {
	defer m.stopped.Signal()
	reObserveDeferralsTicker := time.NewTicker(m.reObserveDeferralsTickerDuration)
	defer reObserveDeferralsTicker.Stop()

	go m.reObserveExpiredDeferrals() // Kick off a run to start with
	for {
		select {
		case <-m.stopSig.Done():
			return
		case <-reObserveDeferralsTicker.C:
			m.reObserveExpiredDeferrals()
		}
	}
}
