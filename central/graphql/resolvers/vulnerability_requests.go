package resolvers

import (
	"context"
	"time"

	"github.com/graph-gophers/graphql-go"
	"github.com/stackrox/rox/central/graphql/resolvers/inputtypes"
	"github.com/stackrox/rox/central/metrics"
	"github.com/stackrox/rox/generated/storage"
	pkgMetrics "github.com/stackrox/rox/pkg/metrics"
	"github.com/stackrox/rox/pkg/utils"
)

func init() {
	schema := getBuilder()
	utils.Must(
		schema.AddType("DeferralRequest", []string{
			"expiresOn: Time",
			"expiresWhenFixed: Boolean!",
		}),
		schema.AddType("VulnerabilityRequest", []string{
			"id: ID!",
			"targetState: String!",
			"status: String!",
			"active: Boolean!",
			"requestor: SlimUser!",
			"approvers: [SlimUser!]!",
			"createdAt: Time",
			"LastUpdated: Time",
			"comments: [RequestComment!]!",
			"scope: VulnerabilityRequest_Scope!",
			"deferralReq: DeferralRequest",
			"falsePositiveReq: FalsePositiveRequest",
			"cves: VulnerabilityRequest_CVEs!",
		}),
		schema.AddMutation("deferVulnerability(request: DeferVulnRequest!): VulnerabilityRequest!"),
		schema.AddMutation("markVulnerabilityFalsePositive(request: FalsePositiveVulnRequest!): VulnerabilityRequest!"),
	)
}

// DeferVulnerability starts the  workflow to defer a vulnerability.
func (resolver *Resolver) DeferVulnerability(ctx context.Context, args struct{ Request inputtypes.DeferVulnRequest }) (*VulnerabilityRequestResolver, error) {
	defer metrics.SetGraphQLOperationDurationTime(time.Now(), pkgMetrics.Root, "DeferVulnerability")
	if err := writeVulnerabilityRequests(ctx); err != nil {
		return nil, err
	}
	response, err := resolver.vulnReqService.DeferVulnerability(ctx, args.Request.AsV1DeferralRequest())
	if err != nil {
		return nil, err
	}
	return resolver.wrapVulnerabilityRequest(response.GetRequestInfo(), err)
}

// MarkVulnerabilityFalsePositive starts the workflow to mark a vulnerability as false-positive.
func (resolver *Resolver) MarkVulnerabilityFalsePositive(ctx context.Context, args struct {
	Request inputtypes.FalsePositiveVulnRequest
}) (*VulnerabilityRequestResolver, error) {
	defer metrics.SetGraphQLOperationDurationTime(time.Now(), pkgMetrics.Root, "MarkVulnerabilityFalsePositive")
	if err := writeVulnerabilityRequests(ctx); err != nil {
		return nil, err
	}

	response, err := resolver.vulnReqService.FalsePositiveVulnerability(ctx, args.Request.AsV1FalsePositiveRequest())
	if err != nil {
		return nil, err
	}
	return resolver.wrapVulnerabilityRequest(response.GetRequestInfo(), err)
}

// VulnerabilityRequestResolver resolves data about a Vulnerability Requests.
type VulnerabilityRequestResolver struct {
	root *Resolver
	data *storage.VulnerabilityRequest
}

func (resolver *Resolver) wrapVulnerabilityRequest(value *storage.VulnerabilityRequest, err error) (*VulnerabilityRequestResolver, error) {
	if err != nil {
		return nil, err
	}
	return &VulnerabilityRequestResolver{root: resolver, data: value}, nil
}

// ID returns the ID of the vulnerability request.
func (vr *VulnerabilityRequestResolver) ID(ctx context.Context) graphql.ID {
	return graphql.ID(vr.data.GetId())
}

// TargetState returns the requested state for the vulnerability.
func (vr *VulnerabilityRequestResolver) TargetState(ctx context.Context) string {
	return vr.data.GetTargetState().String()
}

// Status returns the request status.
func (vr *VulnerabilityRequestResolver) Status(ctx context.Context) string {
	return vr.data.GetStatus().String()
}

// Active returns whether the vulnerability request is in effect or expired.
func (vr *VulnerabilityRequestResolver) Active(ctx context.Context) bool {
	return vr.data.GetActive()
}

// Requestor returns the requestor of the vulnerbility request.
func (vr *VulnerabilityRequestResolver) Requestor(ctx context.Context) (*slimUserResolver, error) {
	return vr.root.wrapSlimUser(vr.data.GetRequestor(), true, nil)
}

// Approvers returns the list of approvers of the vulnerbility request, if any.
func (vr *VulnerabilityRequestResolver) Approvers(ctx context.Context) ([]*slimUserResolver, error) {
	return vr.root.wrapSlimUsers(vr.data.GetApprovers(), nil)
}

// CreatedAt returns the timestamp when the request was created.
func (vr *VulnerabilityRequestResolver) CreatedAt(ctx context.Context) (*graphql.Time, error) {
	return timestamp(vr.data.GetCreatedAt())
}

// LastUpdated returns the timestamp when the request was last updated.
func (vr *VulnerabilityRequestResolver) LastUpdated(ctx context.Context) (*graphql.Time, error) {
	return timestamp(vr.data.GetLastUpdated())
}

// Comments returns the request comments.
func (vr *VulnerabilityRequestResolver) Comments(ctx context.Context) ([]*requestCommentResolver, error) {
	return vr.root.wrapRequestComments(vr.data.GetComments(), nil)
}

// Scope returns the request's scope.
func (vr *VulnerabilityRequestResolver) Scope(ctx context.Context) (*vulnerabilityRequest_ScopeResolver, error) {
	return vr.root.wrapVulnerabilityRequest_Scope(vr.data.GetScope(), true, nil)
}

// DeferralReq returns the deferral request.
func (vr *VulnerabilityRequestResolver) DeferralReq(ctx context.Context) (*DeferralRequestResolver, error) {
	return vr.root.wrapDeferralRequest(vr.data.GetDeferralReq(), nil)
}

// FalsePositiveReq returns the false positive request.
func (vr *VulnerabilityRequestResolver) FalsePositiveReq(ctx context.Context) (*falsePositiveRequestResolver, error) {
	return vr.root.wrapFalsePositiveRequest(vr.data.GetFpRequest(), true, nil)
}

// Cves returns the list of CVEs that the request applies to.
func (vr *VulnerabilityRequestResolver) Cves(ctx context.Context) (*vulnerabilityRequest_CVEsResolver, error) {
	return vr.root.wrapVulnerabilityRequest_CVEs(vr.data.GetCves(), true, nil)
}

// DeferralRequestResolver resolves data about a Vulnerability deferral requests.
type DeferralRequestResolver struct {
	root *Resolver
	data *storage.DeferralRequest
}

func (resolver *Resolver) wrapDeferralRequest(value *storage.DeferralRequest, err error) (*DeferralRequestResolver, error) {
	if err != nil {
		return nil, err
	}
	return &DeferralRequestResolver{root: resolver, data: value}, nil
}

// ExpiresOn returns the deferral request expiry timestamp if the request had a time-based expiry.
func (dr *DeferralRequestResolver) ExpiresOn(ctx context.Context) (*graphql.Time, error) {
	return timestamp(dr.data.GetExpiresOn())
}

// ExpiresWhenFixed returns true if the deferral request expires when vulnerability is fixable.
func (dr *DeferralRequestResolver) ExpiresWhenFixed(ctx context.Context) bool {
	return dr.data.GetExpiresWhenFixed()
}
