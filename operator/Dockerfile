# We have to emulate directory layout as in the repo so that imports in go files work fine.
ARG roxpath=/workspace/src/github.com/stackrox/rox

# Build the manager binary
FROM openshift/origin-release:golang-1.16 as builder
ARG roxpath

# openshift/origin-release:golang-1.16 image comes with `-mod=vendor` in GOFLAGS that forces modules vendoring mechanism
# during the build (see https://golang.org/ref/mod#vendoring). We're not using modules vendoring and so the build fails
# when this flag is on. Here we clear it out.
ENV GOFLAGS=""

# Defines which operator image we're building, should correspond to one of subdirectory names: central or securedcluster.
ARG operator_name

WORKDIR ${roxpath}/
ENV GOPATH=/workspace

# Copy the Go Modules manifests
COPY go.mod go.mod
COPY go.sum go.sum

# Add GitHub hosts as known ones so that git does not complain.
RUN mkdir -p -m 0700 ~/.ssh && ssh-keyscan github.com >> ~/.ssh/known_hosts

# Make sure that private and source-only packages on github.com can be downloaded successfully as go modules.
RUN echo '[url "git@github.com:"]' >> ~/.gitconfig && echo -e '\tinsteadOf = https://github.com/' >> ~/.gitconfig
ENV GOPRIVATE="github.com/stackrox/*"

# Cache deps before building and copying source so that we don't need to re-download as much and so that source changes
# don't invalidate our downloaded layer.
# We're not using `go mod tidy` here becuase go mod tidy needs to examine _source code_ in order to find unused modules.
# There's no source code in this docker layer yet and so `go mod tidy` would empty go.mod and go.sum which is not what
# we want. If we're to COPY source before running `go mod tidy`, local docker build times would go up because any code
# change will invalidate docker layers and will cause modules redownload (during `tidy`). Therefore we use
# `go mod download` as a compromise for shorter local build times due to docker layer caching. There are CI checks
# ensuring that there will not be unused modules for the repo overall.
# Note that `go mod download` can donwload more stuff than `go mod tidy` https://github.com/golang/go/issues/43994
# However it does _not_ seem to resolve packages _incorrectly_ and so should be safe especially given that downloaded
# packages are only used during build and later this docker layer is discarded (only resulting binary goes in the final
# image).
RUN --mount=type=ssh,required=true go mod download

# Copy operator source
COPY operator/${operator_name}/ operator/${operator_name}/
COPY operator/common/ operator/common/

# Copy common packages from repo root
COPY pkg/ pkg/
COPY image/ image/

# Copy generated files from repo root.
# Not generating them during this docker build because they anyway need to be generated by the orchestrating makefiles.
COPY generated/ generated/

# Build
RUN CGO_ENABLED=0 go build -a -o ${operator_name}-operator operator/${operator_name}/main.go

# https://access.redhat.com/containers/?tab=tags#/registry.access.redhat.com/ubi8-minimal
FROM registry.access.redhat.com/ubi8-minimal:8.3
ARG roxpath
ARG operator_name

RUN microdnf update && microdnf clean all && rm -rf /var/cache/yum/*

COPY --from=builder ${roxpath}/${operator_name}-operator /usr/local/bin/
USER nobody:nobody

# Dockerfile ARG is not usable in ENTRYPOINT, therefore we communicate operator's executable through env variable.
# See https://stackoverflow.com/a/47643816
ENV operator_executable=${operator_name}-operator
# `, "--"` in the end is needed to tell bash give all command line arguments to our script, otherwise it will steal the
# first argument and never give it to the script.
ENTRYPOINT ["/usr/bin/bash", "-uc", "exec /usr/local/bin/${operator_executable} \"${@}\"", "--"]
